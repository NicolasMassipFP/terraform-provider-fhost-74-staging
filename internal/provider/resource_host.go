// Code generated by tfsmcgen. DO NOT EDIT.
// This file was automatically generated from OpenAPI schema: Host
// Package provider implements the SMC Terraform provider resources and data sources.
package provider




import (
	"context"
	"encoding/json"
	"fmt"
	"strings"


	"github.com/hashicorp/terraform-plugin-framework/path"
	"github.com/hashicorp/terraform-plugin-framework/resource"
	"github.com/hashicorp/terraform-plugin-framework/resource/schema"
	"github.com/hashicorp/terraform-plugin-framework/types"
	"github.com/hashicorp/terraform-plugin-log/tflog"

	"github.com/terraform-providers/terraform-provider-smc/internal/apijson"
	"github.com/terraform-providers/terraform-provider-smc/internal/sdk/request"
	"github.com/terraform-providers/terraform-provider-smc/internal/smc"
)


// Ensure provider defined types fully satisfy framework interfaces.
var _ resource.Resource = &HostResource{}
var _ resource.ResourceWithImportState = &HostResource{}
var _ context.Context = context.Background()
// var _ resource.ResourceWithModifyPlan = &HostResource{}

// Schema defines the schema for the Host resource.
func (r *HostResource) Schema(ctx context.Context, _ resource.SchemaRequest, resp *resource.SchemaResponse) {
	resp.Schema = schema.Schema{
      Description: "This represents a Host, which is a Network Element that represents any single device that has an IP address. Any device connected to a TCP/IP network, including the Internet, with one or more IP addresses. Hosts are distinguishable from gateways or routers, in that they do not forward, or route, packets to other networks.",
      Attributes: GetHostSchemaAttributes(ctx),
      Blocks: GetHostSchemaBlocks(ctx),
    } // schema
    

}

// NewHostResource creates a new instance of the Host resource.
func NewHostResource() resource.Resource {
	tflog.Debug(context.Background(), "Initializing Host resource")
	return &HostResource{}
}

// HostResource defines the resource implementation.
type HostResource struct {
	client *smc.Client
	config *request.GenericCRUDConfig
}

// Metadata returns the resource type name.
func (r *HostResource) Metadata(_ context.Context, req resource.MetadataRequest, resp *resource.MetadataResponse) {
	resp.TypeName = req.ProviderTypeName + "_host"
}

// Configure adds the provider configured client to the resource.
func (r *HostResource) Configure(ctx context.Context, req resource.ConfigureRequest, resp *resource.ConfigureResponse) {
	// Prevent panic if the provider has not been configured.
	if req.ProviderData == nil {
		return
	}

	client, ok := req.ProviderData.(*smc.Client)
	if !ok {
		resp.Diagnostics.AddError(
			"Unexpected Resource Configure Type",
			fmt.Sprintf("Expected *smc.Client, got: %T. Please report this issue to the provider developers.", req.ProviderData),
		)
		return
	}

	// Ensure client is logged in
	if err := client.Login(ctx); err != nil {
		resp.Diagnostics.AddError(
			"SMC Login Failed",
			fmt.Sprintf("Unable to login to SMC: %s", err.Error()),
		)
		return
	}

	r.client = client
	r.config = &request.GenericCRUDConfig{
		BaseURL:                   client.URL,
		APIVersion:                client.APIVersion,
		Auth:                     client.Auth,
		ResourceType:             "host",
		GetJSONHeaders:           client.GetJSONHeaders,
		GetAuthHeaders:           client.GetAuthHeaders,
		GetJSONHeadersWithEtag:   client.GetJSONHeadersWithEtag,
		GetAuthHeadersWithEtag:   client.GetAuthHeadersWithEtag,
	}
}



// include 'resource_plan.j2'
// Create creates a new Host resource.
func (r *HostResource) Create(ctx context.Context, req resource.CreateRequest, resp *resource.CreateResponse) {
	if r.client == nil {
		resp.Diagnostics.AddError(
			"Unconfigured SMC Client",
			"Expected configured SMC client. Please report this issue to the provider developers.",
		)
		return
	}

	var data HostResourceModel

	// Read Terraform plan data into the model
	resp.Diagnostics.Append(req.Plan.Get(ctx, &data)...)
	if resp.Diagnostics.HasError() {
		return
	}

	// Convert Terraform model to API model
	apiData, err := apijson.MarshalRoot(data)
	if err != nil {
		resp.Diagnostics.AddError(
			"Error marshalling resource data",
			fmt.Sprintf("Could not marshal resource data to JSON: %s", err.Error()),
		)
		return
	}

	// Parse the JSON back to interface{} for the generic create
	var resourceData interface{}
	if err := json.Unmarshal(apiData, &resourceData); err != nil {
		resp.Diagnostics.AddError(
			"Error processing resource data",
			fmt.Sprintf("Could not process resource data: %s", err.Error()),
		)
		return
	}

	tflog.Info(ctx, fmt.Sprintf("Creating host: %s", string(apiData)))

	// False
	// Create the resource using generic CRUD
	createResp, err := request.CreateResource(r.config, resourceData)
	if err != nil {
		resp.Diagnostics.AddError(
			"Error creating host",
			fmt.Sprintf("Could not create host: %s", err.Error()),
		)
		return
	}

	// Read the created resource to get full details
	var createdData HostResourceModel
	readResp, err := request.ReadResourceByHref(r.config, createResp.Location)
	if err != nil {
		resp.Diagnostics.AddError(
			"Error reading created host",
			fmt.Sprintf("Could not read created host: %s", err.Error()),
		)
		return
	}

    tflog.Debug(ctx, fmt.Sprintf("Reading Host after create: +%v", string(readResp.Body[:])))

	// Unmarshal the response into our model
	if err := apijson.UnmarshalRoot(readResp.Body, &createdData); err != nil {
		resp.Diagnostics.AddError(
			"Error parsing created host",
			fmt.Sprintf("Could not parse created host: %s", err.Error()),
		)
		return
	}

	MergeResourceModels(ctx, /*src*/&createdData, /*dest*/&data)
    data.ID = types.StringValue(createResp.Location)
	resp.Diagnostics.Append(resp.State.Set(ctx, &data)...)

	tflog.Debug(ctx, "Created host successfully")
}
// Read refreshes the Terraform state with the latest data.
func (r *HostResource) Read(ctx context.Context, req resource.ReadRequest, resp *resource.ReadResponse) {

	tflog.Info(ctx, "Beginning Read of host")

}




func (m *HostResourceModel) GetSelfHref(ctx context.Context) (string, error) {
    if m.Link.IsNullOrUnknown() {
        return "", fmt.Errorf("link attribute is null or unknown")
    }

    links, diags := m.Link.AsStructSliceT(ctx)
    if diags.HasError() {
        return "", fmt.Errorf("failed to convert links to struct slice: %v", diags)
    }

    for _, link := range links {
        if !link.Rel.IsNull() && link.Rel.ValueString() == "self" {
            if !link.Href.IsNull() {
                return link.Href.ValueString(), nil
            }
        }
    }

    return "", fmt.Errorf("self link not found")
}

// Delete removes the Host resource from Terraform state and deletes it from the API.
func (r *HostResource) Delete(
	ctx context.Context, req resource.DeleteRequest, resp *resource.DeleteResponse) {
	if r.client == nil {
		resp.Diagnostics.AddError(
			"Unconfigured SMC Client",
			"Expected configured SMC client. Please report this issue to the provider developers.",
		)
		return
	}

	var data HostResourceModel

	// Read Terraform prior state data into the model
	resp.Diagnostics.Append(req.State.Get(ctx, &data)...)
	if resp.Diagnostics.HasError() {
		return
	}

	href, err := data.GetSelfHref(ctx)
	if err != nil {
		resp.Diagnostics.AddError(
			"Error retrieving resource href",
			fmt.Sprintf("Could not retrieve href for host: %s", err.Error()),
		)
		return
	}

	readResp, err := request.ReadResourceByHref(r.config, href)
	if err != nil {
		resp.Diagnostics.AddError(
			"Error reading host before deletion",
			fmt.Sprintf("Could not read host: %s", err.Error()),
		)
		return
	}
	request.DeleteResourceByHref(r.config, href, (*readResp).ETag)
	tflog.Debug(ctx, fmt.Sprintf("Deleted host '%s' successfully", href))
}

// Update modifies the Host resource and updates the Terraform state on success.
func (r *HostResource) Update(ctx context.Context, req resource.UpdateRequest, resp *resource.UpdateResponse) {
	if r.client == nil {
		resp.Diagnostics.AddError(
			"Unconfigured SMC Client",
			"Expected configured SMC client. Please report this issue to the provider developers.",
		)
		return
	}

	var data HostResourceModel
	var stateData HostResourceModel

	// Read Terraform plan data into the model
	resp.Diagnostics.Append(req.Plan.Get(ctx, &data)...)
	if resp.Diagnostics.HasError() {
		return
	}

	// Read current state data to preserve readonly fields
	resp.Diagnostics.Append(req.State.Get(ctx, &stateData)...)
	if resp.Diagnostics.HasError() {
		return
	}

	// Extract optional resource name for update
	resourceName := "n/a"
	if !data.Name.IsNull() && !data.Name.IsUnknown() {
		resourceName = data.Name.ValueString()
	}

	MergeResourceModels(ctx, /*src*/&stateData, /*dest*/&data, "key", "tag", "parent_insert_point", "parent_policy")

	// Convert Terraform model to API model
	apiData, err := apijson.MarshalRoot(data)
	if err != nil {
		resp.Diagnostics.AddError(
			"Error marshalling resource data",
			fmt.Sprintf("Could not marshal resource data to JSON: %s", err.Error()),
		)
		return
	}

	// Parse the JSON back to interface{} for the generic update
	var resourceData interface{}
	if err := json.Unmarshal(apiData, &resourceData); err != nil {
		resp.Diagnostics.AddError(
			"Error processing resource data",
			fmt.Sprintf("Could not process resource data: %s", err.Error()),
		)
		return
	}

	id := stateData.ID.ValueString()
	tflog.Info(ctx, fmt.Sprintf("Updating host '%s' with ID: '%s': %s",
		resourceName, id, string(apiData)))

	// Update the resource using generic CRUD
	updateResp, err := request.UpdateResource(r.config, resourceData, id)
	if err != nil {
		tflog.Error(context.Background(), fmt.Sprintf("Error update: %s", id))
		resp.Diagnostics.AddError(
			"Error updating host",
			fmt.Sprintf("Could not update host '%s': %s", resourceName, err.Error()),
		)
		return
	}

	// Read the updated resource to get full details
	var updatedData HostResourceModel
	if updateResp.Location == "" {
		resp.Diagnostics.AddError(
			"Internal Error during update of host",
			"Location missing",
		)
		return
	}
	readResp, err := request.ReadResourceByHref(r.config, updateResp.Location)
	if err != nil {
		resp.Diagnostics.AddError(
			"Error reading updated host",
			fmt.Sprintf("Could not read updated host: %s", err.Error()),
		)
		return
	}

	// Unmarshal the response into our model
	if err := apijson.UnmarshalRoot(readResp.Body, &updatedData); err != nil {
		resp.Diagnostics.AddError(
			"Error parsing updated host",
			fmt.Sprintf("Could not parse updated host: %s", err.Error()),
		)
		return
	}


	MergeResourceModels(ctx, /*src*/&updatedData, /*dest*/&data)
    data.ID = types.StringValue(updateResp.Location)
	resp.Diagnostics.Append(resp.State.Set(ctx, &data)...)

}
// ImportState imports a Host resource into Terraform state.
func (r *HostResource) ImportState(ctx context.Context, req resource.ImportStateRequest, resp *resource.ImportStateResponse) {
	id := req.ID
	// If the ID looks like a URL, use it directly
	if strings.HasPrefix(id, "http") {
		resp.Diagnostics.Append(resp.State.SetAttribute(ctx, path.Root("id"), id)...) 
		return
	}

	// Otherwise, look up by name and type
	config := r.config
	// Set the resource type for lookup (customize if needed)
	config.ResourceType = "Host" // or hardcode if always 'host'
	readResp, err := request.ReadResourceByName(config, id)
	if err != nil {
		resp.Diagnostics.AddError(
			"Import failed",
			fmt.Sprintf("Could not find Host with name '%s': %s", id, err.Error()),
		)
		return
	}
	if readResp == nil || readResp.Location == "" {
		resp.Diagnostics.AddError(
			"Import failed",
			fmt.Sprintf("No Host found with name '%s'", id),
		)
		return
	}
	resp.Diagnostics.Append(resp.State.SetAttribute(ctx, path.Root("id"), readResp.Location)...) 
}
